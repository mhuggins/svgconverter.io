var Le=Object.defineProperty;var Ye=(K,X,C)=>X in K?Le(K,X,{enumerable:!0,configurable:!0,writable:!0,value:C}):K[X]=C;var z=(K,X,C)=>Ye(K,typeof X!="symbol"?X+"":X,C);(function(){"use strict";var K=(t=>(t.sRGB="srgb",t.Lab="lab",t))(K||{}),X=(t=>(t.Pixel="pixel",t.Path="path",t))(X||{});const C=t=>e=>{var o;return((o=e.byKind.get(t))!=null?o:[]).slice(-1).map(r=>e.artifacts.get(r))};function F(t,e){var s;const n=new Map(t.artifacts),o=new Map(t.byKind),r=new Map(t.tags);for(const a of e){n.set(a.id,a);const c=(s=o.get(a.kind))!=null?s:[];c.push(a.id),o.set(a.kind,c)}return{artifacts:n,byKind:o,tags:r}}const P=()=>crypto.randomUUID();class Dt{log(...e){}warn(...e){}error(...e){}trace(...e){}}const zt=new Dt;class st{constructor(e,n=[]){z(this,"name");z(this,"steps");this.name=e,this.steps=[...n]}async execute(e=[],n={}){const{onProgress:o,logger:r=zt}=n;let a=F({artifacts:new Map,byKind:new Map,tags:new Map},e);r.log(`Starting pipeline: ${this.name} with ${this.steps.length} steps`),r.log(`Seed artifacts: ${e.map(i=>i.kind).join(", ")}`);for(let i=0;i<this.steps.length;i++){const l=this.steps[i];r.log(`Executing step ${i+1}/${this.steps.length}: ${l.desc.name}`);try{if(!this.canStepExecute(l,a)){r.warn(`Step ${l.desc.name} skipped - missing required inputs: ${l.desc.consumes.join(", ")}`);continue}const f=Date.now();a=await l.run(a);const g=Date.now()-f;r.log(`Step ${l.desc.name} completed in ${g}ms`),r.log(`Produced: ${l.desc.produces.join(", ")}`),o==null||o((i+1)/this.steps.length*100,i+1,this.steps.length)}catch(d){const f=`Pipeline step ${l.desc.name} failed: ${d instanceof Error?d.message:"Unknown error"}`;throw r.error(f),new Error(f)}}r.log(`Pipeline ${this.name} completed with ${a.artifacts.size} total artifacts`);const c=Array.from(a.byKind.entries()).map(([i,l])=>`${i}: ${l.length}`).join(", ");return r.log(`Final artifacts: ${c}`),a}canStepExecute(e,n){for(const o of e.desc.consumes){const r=n.byKind.get(o);if(!r||r.length===0)return!1}return!0}addStep(e){this.steps.push(e)}removeStep(e){const n=this.steps.findIndex(o=>o.desc.name===e);n>=0&&this.steps.splice(n,1)}getStep(e){return this.steps.find(n=>n.desc.name===e)}clone(e){return new st(e||`${this.name}_copy`,[...this.steps])}getExecutionPlan(e){const n={artifacts:new Map,byKind:new Map(e.map(s=>[s,["mock"]])),tags:new Map},o=[],r=[];for(const s of this.steps)if(this.canStepExecute(s,n)){o.push(s.desc.name);for(const a of s.desc.produces)n.byKind.has(a)||n.byKind.set(a,["mock"])}else r.push(s.desc.name);return{executableSteps:o,skippedSteps:r}}}function rt(t,e,n){if(t.length<=2)return t;let o=0,r=0;const s=t[0],a=t[t.length-1];for(let i=1;i<t.length-1;i++){if(n!=null&&n.has(i))continue;const l=dt(t[i],s,a);l>o&&(o=l,r=i)}if(o===0&&n){for(let i=1;i<t.length-1;i++)if(n.has(i)){r=i,o=e+1;break}}if(o>e){const i=n?new Set([...n].filter(g=>g<=r)):void 0,l=n?new Set([...n].filter(g=>g>=r).map(g=>g-r)):void 0,d=rt(t.slice(0,r+1),e,i),f=rt(t.slice(r),e,l);return[...d.slice(0,-1),...f]}const c=[s];if(n)for(let i=1;i<t.length-1;i++)n.has(i)&&c.push(t[i]);return c.push(a),c}function dt(t,e,n){const[o,r]=t,[s,a]=e,[c,i]=n,l=c-s,d=i-a;if(l===0&&d===0)return Math.hypot(o-s,r-a);const f=Math.abs(d*o-l*r+c*a-i*s),g=Math.hypot(l,d);return f/g}function Pt(t,e,n,o=.5){if(n-e<2)return!0;const r=t[e],s=t[n];if(Math.hypot(s[0]-r[0],s[1]-r[1])<1e-6)return!0;let c=0;for(let i=e+1;i<n;i++){const l=dt(t[i],r,s);c=Math.max(c,l)}return c<o}function Tt(t,e,n,o,r=50,s){const a=t[e];let c=Math.min(e+r,t.length-1);if(s){for(let d=e+1;d<=c;d++)if(s.has(d)){c=d;break}}let i=null;for(let d=c;d>e;d--){const f=t[d];if(Math.hypot(f[0]-a[0],f[1]-a[1])<o&&d===e+1)return{type:"line",end:f,endIndex:d,cp1:a,cp2:f};const h=t.slice(e,d+1);if(h.length<3){i={type:"line",end:f,endIndex:d,cp1:a,cp2:f};continue}const m=Ft(h);if(Lt(h,m)<=n){i={type:"curve",end:m.p3,endIndex:d,cp1:m.p1,cp2:m.p2};break}}if(i&&i.type==="curve"&&i.endIndex-e>=4&&Pt(t,e,i.endIndex,n*.75)&&(i={type:"line",end:i.end,endIndex:i.endIndex,cp1:a,cp2:i.end}),i)return i;const l=e+1;return{type:"line",end:t[l],endIndex:l,cp1:a,cp2:t[l]}}function Ft(t){const e=t[0],n=t[t.length-1],o=ft(t,0),r=ft(t,t.length-1),{alpha:s,beta:a}=Bt(t,o,r),c=[e[0]+s*o[0],e[1]+s*o[1]],i=[n[0]-a*r[0],n[1]-a*r[1]];return{p0:e,p1:c,p2:i,p3:n}}function ft(t,e){if(e===0){const s=t[1][0]-t[0][0],a=t[1][1]-t[0][1],c=Math.hypot(s,a);return c>0?[s/c,a/c]:[1,0]}if(e===t.length-1){const s=t[e][0]-t[e-1][0],a=t[e][1]-t[e-1][1],c=Math.hypot(s,a);return c>0?[s/c,a/c]:[1,0]}const n=t[e+1][0]-t[e-1][0],o=t[e+1][1]-t[e-1][1],r=Math.hypot(n,o);return r>0?[n/r,o/r]:[1,0]}function Bt(t,e,n){let o=0,r=0,s=0,a=0,c=0;const i=t[0],l=t[t.length-1];for(let h=1;h<t.length-1;h++){const m=h/(t.length-1),y=1-m,v=y*y*y,p=3*y*y*m,w=3*y*m*m,A=m*m*m,$=p,M=w;o+=$*$,r+=$*M,s+=M*M;const b=t[h][0]-v*i[0]-A*l[0],u=t[h][1]-v*i[1]-A*l[1];a+=$*(b*e[0]+u*e[1]),c+=M*(-b*n[0]-u*n[1])}const d=o*s-r*r;if(Math.abs(d)<1e-10){const h=Math.hypot(l[0]-i[0],l[1]-i[1]);return{alpha:h/3,beta:h/3}}const f=(a*s-c*r)/d,g=(o*c-r*a)/d;return{alpha:Math.max(0,f),beta:Math.max(0,g)}}function Lt(t,e){let n=0;for(let o=1;o<t.length-1;o++){const r=o/(t.length-1),s=Yt(e,r),a=Math.hypot(t[o][0]-s[0],t[o][1]-s[1]);n=Math.max(n,a)}return n}function Yt(t,e){const n=1-e,o=n*n*n,r=3*n*n*e,s=3*n*e*e,a=e*e*e;return[o*t.p0[0]+r*t.p1[0]+s*t.p2[0]+a*t.p3[0],o*t.p0[1]+r*t.p1[1]+s*t.p2[1]+a*t.p3[1]]}class Nt{constructor(e={}){z(this,"desc",{name:"paths/bezier-fitting",consumes:["topology/region-contours"],produces:["paths/bezier"]});this.config=e}async run(e){var i,l,d;const[n]=C("topology/region-contours")(e);if(!n)return e;const o=(i=this.config.tolerance)!=null?i:1,r=(l=this.config.minSegmentLength)!=null?l:4,s=(d=this.config.maxLookAhead)!=null?d:50,a=[];for(const f of n.contours){const g=gt(f.outer,o,r,s),h=f.holes.map(y=>gt(y,o,r,s)),m=[g,...h].join(" ");a.push({regionId:f.regionId,d:m})}const c={id:P(),kind:"paths/bezier",paths:a,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{tolerance:o,minSegmentLength:r,maxLookAhead:s}}};return F(e,[c])}}function gt(t,e,n,o){const r=t.points,s=r.length/2;if(s<2)return"";const a=[];for(let f=0;f<s;f++)a.push([r[f*2],r[f*2+1]]);const c=rt(a,e,t.sharedVertexIndices);if(c.length<2)return"";const i=new Set;if(t.sharedVertexIndices&&t.sharedVertexIndices.size>0)for(let f=0;f<c.length;f++){const g=c[f];for(let h=0;h<a.length;h++)if(a[h][0]===g[0]&&a[h][1]===g[1]){t.sharedVertexIndices.has(h)&&i.add(f);break}}const l=[];l.push(`M ${c[0][0].toFixed(2)} ${c[0][1].toFixed(2)}`);let d=1;for(;d<c.length;){const f=Tt(c,d-1,e,n,o,i);f.type==="line"?(l.push(`L ${f.end[0].toFixed(2)} ${f.end[1].toFixed(2)}`),d=f.endIndex+1):(l.push(`C ${f.cp1[0].toFixed(2)} ${f.cp1[1].toFixed(2)}, ${f.cp2[0].toFixed(2)} ${f.cp2[1].toFixed(2)}, ${f.end[0].toFixed(2)} ${f.end[1].toFixed(2)}`),d=f.endIndex+1)}return t.closed&&l.push("Z"),l.join(" ")}class Xt{constructor(e={}){z(this,"desc",{name:"filter/bilateral",consumes:["raster/rgb"],produces:["raster/rgb"]});this.config=e}async run(e){var f,g,h;const[n]=C("raster/rgb")(e);if(!n)return e;const o=(f=this.config.sigmaSpatial)!=null?f:3,r=(g=this.config.sigmaRange)!=null?g:.1,s=(h=this.config.radius)!=null?h:Math.ceil(o*2),{width:a,height:c,data:i}=n,l=qt(i,a,c,o,r,s),d={id:P(),kind:"raster/rgb",width:a,height:c,channels:4,data:l,coordSpace:n.coordSpace,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{sigmaSpatial:o,sigmaRange:r,radius:s}}};return F(e,[d])}}function qt(t,e,n,o,r,s){const a=new Float32Array(t.length),c=new Float32Array((s*2+1)*(s*2+1)),i=o*o;let l=0;for(let f=-s;f<=s;f++)for(let g=-s;g<=s;g++){const h=g*g+f*f;c[l++]=Math.exp(-h/(2*i))}const d=r*r;for(let f=0;f<n;f++)for(let g=0;g<e;g++){const h=(f*e+g)*4,m=t[h],y=t[h+1],v=t[h+2],p=t[h+3];let w=0,A=0,$=0,M=0,b=0,u=0;for(let x=-s;x<=s;x++){const S=f+x;if(S<0||S>=n){u+=s*2+1;continue}for(let E=-s;E<=s;E++){const I=g+E;if(I<0||I>=e){u++;continue}const D=(S*e+I)*4,R=t[D],T=t[D+1],G=t[D+2],W=t[D+3],L=m-R,N=y-T,q=v-G,U=L*L+N*N+q*q,V=Math.exp(-U/(2*d)),Y=c[u]*V;w+=R*Y,A+=T*Y,$+=G*Y,M+=W*Y,b+=Y,u++}}b>0?(a[h]=w/b,a[h+1]=A/b,a[h+2]=$/b,a[h+3]=M/b):(a[h]=m,a[h+1]=y,a[h+2]=v,a[h+3]=p)}return a}class Vt{constructor(e={}){z(this,"desc",{name:"style/color-reconstruction",consumes:["map/region-id","raster/rgb","regions/final"],optional:["raster/source"],produces:["style/fills","palette/final"]});this.config=e}async run(e){var d,f,g,h,m;const[n]=C("map/region-id")(e),[o]=C("raster/rgb")(e),[r]=C("raster/source")(e),[s]=C("regions/final")(e);if(!n||!o||!s)return e;const a=s.regions.map(()=>({r:0,g:0,b:0,a:0,count:0}));for(let y=0;y<n.data.length;y++){const v=n.data[y],p=(d=a[v])!=null?d:a[v]={r:0,g:0,b:0,a:0,count:0},w=y*4;if(r){const A=r.data;p.r+=((f=A[w])!=null?f:0)/255,p.g+=((g=A[w+1])!=null?g:0)/255,p.b+=((h=A[w+2])!=null?h:0)/255,p.a+=((m=A[w+3])!=null?m:255)/255}else p.r+=o.data[w],p.g+=o.data[w+1],p.b+=o.data[w+2],p.a+=o.data[w+3];p.count++}const c=s.regions.map((y,v)=>{var $;const p=($=a[v])!=null?$:{r:0,g:0,b:0,a:1,count:1},w=p.count>0?1/p.count:1,A=Gt(p.a*w);return{regionId:y.id,fill:{r:Math.round(p.r*w*255),g:Math.round(p.g*w*255),b:Math.round(p.b*w*255),a:Math.round(A*255)},opacity:A}}),i={id:P(),kind:"style/fills",fills:c,background:this.config.background,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:r?[n.id,o.id,r.id]:[n.id,o.id]}},l={id:P(),kind:"palette/final",colors:c.map(y=>({rgba:y.fill})),provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[i.id]}};return F(e,[i,l])}}function Gt(t){return Number.isNaN(t)||t<0?0:t>1?1:t}function Ut(t,e,n){const o=t*.4124564+e*.3575761+n*.1804375,r=t*.2126729+e*.7151522+n*.072175,s=t*.0193339+e*.119192+n*.9503041;return[o,r,s]}function Kt(t,e,n){const a=it(t/.95047),c=it(e/1),i=it(n/1.08883),l=116*c-16,d=500*(a-c),f=200*(c-i);return[l,d,f]}function it(t){const e=.20689655172413793,n=e*e*e;return t>n?Math.cbrt(t):t/(3*e*e)+4/29}function Q(t,e,n){const o=at(t),r=at(e),s=at(n),[a,c,i]=Ut(o,r,s);return Kt(a,c,i)}function at(t){return t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function ht(t,e,n,o,r,s){const a=t-o,c=e-r,i=n-s;return Math.sqrt(a*a+c*c+i*i)}function ut(t,e,n,o,r,s){const a=t-o,c=e-r,i=n-s;return a*a+c*c+i*i}class Ot{constructor(){z(this,"desc",{name:"convert/rgb-to-lab",consumes:["raster/rgb"],produces:["raster/lab"]})}async run(e){const[n]=C("raster/rgb")(e);if(!n)return e;const{width:o,height:r,data:s}=n,a=o*r,c=new Float32Array(a*4);for(let l=0;l<a;l++){const d=l*4,f=s[d],g=s[d+1],h=s[d+2],m=s[d+3],[y,v,p]=Q(f,g,h);c[d]=y,c[d+1]=v,c[d+2]=p,c[d+3]=m}const i={id:P(),kind:"raster/lab",width:o,height:r,channels:4,data:c,coordSpace:n.coordSpace,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id]}};return F(e,[i])}}class jt{constructor(e={}){z(this,"desc",{name:"topology/dcel-contours",consumes:["map/region-id","regions/final"],optional:["raster/lab","raster/rgb"],produces:["topology/region-contours"]});this.config=e}async run(e){var A,$,M,b,u;const[n]=C("map/region-id")(e),[o]=C("regions/final")(e);if(!n||!o)return e;const{width:r,height:s,data:a}=n,[c]=C("raster/lab")(e),[i]=C("raster/rgb")(e),l=c||i,d=(A=this.config.useSubpixelRefinement)!=null?A:!0,f=($=this.config.gradientThreshold)!=null?$:.1,g=new Wt(d&&l?l:null,f);for(let x=0;x<s;x++)for(let S=0;S<r;S++){const E=a[x*r+S];if(x===0||a[(x-1)*r+S]!==E){const I=x===0?-1:a[(x-1)*r+S];g.addEdge(S,x,S+1,x,E,I)}if(S===r-1||a[x*r+S+1]!==E){const I=S===r-1?-1:a[x*r+S+1];g.addEdge(S+1,x,S+1,x+1,E,I)}if(x===s-1||a[(x+1)*r+S]!==E){const I=x===s-1?-1:a[(x+1)*r+S];g.addEdge(S+1,x+1,S,x+1,E,I)}if(S===0||a[x*r+S-1]!==E){const I=S===0?-1:a[x*r+S-1];g.addEdge(S,x+1,S,x,E,I)}}const{vertexById:h,halfEdgeById:m,faceById:y}=g.build();if((M=this.config.useDCELSmoothing)!=null?M:!1){const x=(b=this.config.dcelSmoothingIterations)!=null?b:3,S=(u=this.config.dcelSmoothingLambda)!=null?u:.5;this.smoothDCELVertices(h,m,x,S)}const p=[];y.forEach(x=>{if(x.id===-1)return;const S=this.tracePolyline(x.outerEdge,m,h),E=x.holes.map(I=>this.tracePolyline(I,m,h));p.push({regionId:x.id,outer:S,holes:E})});const w={id:P(),kind:"topology/region-contours",width:r,height:s,contours:p,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id,o.id]}};return F(e,[w])}tracePolyline(e,n,o){const r=[],s=new Set;let a=e;const c=new Set;let i=0;for(;!c.has(a);){c.add(a);const l=n.get(a);if(!l)break;const d=o.get(l.origin);if(d){r.push(d.x,d.y);const f=n.get(l.twin);f&&f.face!==-1&&f.face!==l.face&&s.add(i),i++}if(l.next===-1||l.next===e)break;a=l.next}return{points:new Float32Array(r),closed:!0,sharedVertexIndices:s}}smoothDCELVertices(e,n,o,r){const s=this.buildVertexAdjacency(n);for(let a=0;a<o;a++){const c=new Map;e.forEach(i=>{const l=s.get(i.id)||[];if(l.length===0){c.set(i.id,{x:i.x,y:i.y});return}let d=0,f=0;for(const v of l){const p=e.get(v);p&&(d+=p.x,f+=p.y)}const g=d/l.length,h=f/l.length,m=r*g+(1-r)*i.x,y=r*h+(1-r)*i.y;c.set(i.id,{x:m,y})}),c.forEach((i,l)=>{const d=e.get(l);d&&(d.x=i.x,d.y=i.y)})}}buildVertexAdjacency(e){const n=new Map;e.forEach(r=>{const s=r.origin,a=e.get(r.twin);if(a){const c=a.origin;n.has(s)||n.set(s,new Set),n.get(s).add(c)}});const o=new Map;return n.forEach((r,s)=>{o.set(s,Array.from(r))}),o}}class Wt{constructor(e,n){z(this,"vertices",new Map);z(this,"halfEdges",[]);z(this,"faces",new Map);z(this,"edgeMap",new Map);z(this,"nextVertexId",0);z(this,"nextEdgeId",0);this.colorData=e,this.gradientThreshold=n}addEdge(e,n,o,r,s,a){const[c,i]=this.computeSubpixelPosition(e,n,s),[l,d]=this.computeSubpixelPosition(o,r,s),f=this.getOrCreateVertex(c,i),g=this.getOrCreateVertex(l,d),h=this.edgeKey(f,g),m=this.edgeKey(g,f);if(this.edgeMap.has(h))return;const y=this.nextEdgeId++,v=this.nextEdgeId++,p={id:y,origin:f,twin:v,next:-1,prev:-1,face:s},w={id:v,origin:g,twin:y,next:-1,prev:-1,face:a};this.halfEdges.push(p),this.halfEdges.push(w),this.edgeMap.set(h,y),this.edgeMap.set(m,v),this.faces.has(s)||this.faces.set(s,{id:s,outerEdge:y,holes:[]}),a!==-1&&!this.faces.has(a)&&this.faces.set(a,{id:a,outerEdge:v,holes:[]})}build(){const e=new Map,n=new Map;for(const s of this.halfEdges){const a=s.origin,c=this.halfEdges[s.twin].origin;e.has(a)||e.set(a,[]),n.has(c)||n.set(c,[]),e.get(a).push(s.id),n.get(c).push(s.id)}const o=new Map(Array.from(this.vertices.values()).map(s=>[s.id,s]));for(const s of this.halfEdges){const a=this.halfEdges[s.twin].origin,c=o.get(a),i=o.get(s.origin);if(!c||!i)continue;const d=(e.get(a)||[]).filter(f=>this.halfEdges[f].face===s.face);if(d.length===1){const f=d[0];s.next=f,this.halfEdges[f].prev=s.id}else if(d.length>1){const f=Math.atan2(c.y-i.y,c.x-i.x);let g=-1,h=-1/0;for(const m of d){const y=this.halfEdges[m],v=this.halfEdges[y.twin].origin,p=o.get(v);if(!p)continue;let A=Math.atan2(p.y-c.y,p.x-c.x)-f;A<=0&&(A+=2*Math.PI),A>h&&(h=A,g=m)}g!==-1&&(s.next=g,this.halfEdges[g].prev=s.id)}}const r=new Map(this.halfEdges.map(s=>[s.id,s]));return this.detectHoles(r,o),{vertexById:o,halfEdgeById:r,faceById:this.faces}}detectHoles(e,n){const o=new Map;this.faces.forEach(r=>{if(r.id===-1)return;const s=[],a=new Set;e.forEach(c=>{if(c.face!==r.id||a.has(c.id))return;const i=[];let l=c.id;for(;!a.has(l);){a.add(l),i.push(l);const d=e.get(l);if(!d||d.next===-1||d.next===c.id)break;l=d.next}i.length>0&&s.push(i)}),o.set(r.id,s)}),o.forEach((r,s)=>{if(r.length===0)return;const a=r.map(d=>{let f=0;for(const g of d){const h=e.get(g);if(!h)continue;const m=n.get(h.origin),y=e.get(h.twin);if(!y)continue;const v=n.get(y.origin);m&&v&&(f+=(v.x-m.x)*(v.y+m.y))}return f});let c=0,i=a[0];for(let d=1;d<a.length;d++)a[d]>i&&(i=a[d],c=d);const l=this.faces.get(s);l&&(l.outerEdge=r[c][0],l.holes=r.map((d,f)=>f!==c?d[0]:-1).filter(d=>d!==-1))})}getOrCreateVertex(e,n){const o=Math.round(e*1e3)/1e3,r=Math.round(n*1e3)/1e3,s=`${o},${r}`;if(this.vertices.has(s))return this.vertices.get(s).id;const a=this.nextVertexId++;return this.vertices.set(s,{id:a,x:o,y:r}),a}edgeKey(e,n){return`${e}->${n}`}computeSubpixelPosition(e,n,o){if(!this.colorData)return[e,n];const{data:r,width:s,height:a}=this.colorData,c=r.length/(s*a),i=[];for(const[b,u]of[[-1,0],[1,0],[0,-1],[0,1]]){const x=Math.floor(e)+b,S=Math.floor(n)+u;if(x>=0&&x<s&&S>=0&&S<a){const E=(S*s+x)*c,I=Array.from(r.slice(E,E+c));i.push({dx:b,dy:u,color:I})}}if(i.length<2)return[e,n];let l=0,d=null;for(let b=0;b<i.length;b++)for(let u=b+1;u<i.length;u++){const x=mt(i[b].color,i[u].color);x>l&&(l=x,d=[i[b],i[u]])}if(!d||l<this.gradientThreshold)return[e,n];const[f,g]=d,h=[g.dx-f.dx,g.dy-f.dy],m=Math.sqrt(h[0]**2+h[1]**2);if(m<.01)return[e,n];const y=[h[0]/m,h[1]/m],v=l,A=(mt(f.color,g.color)/v-.5)*.5,$=e+y[0]*A,M=n+y[1]*A;return[$,M]}}function mt(t,e){let n=0;for(let o=0;o<Math.min(t.length,e.length);o++)n+=(t[o]-e[o])**2;return Math.sqrt(n)}class _t{constructor(e={}){z(this,"desc",{name:"regions/detail-selection",consumes:["regions/hierarchy","map/region-id"],optional:["palette/local-grid"],produces:["regions/final","map/region-id"]});this.config=e}async run(e){var $,M;const[n]=C("regions/hierarchy")(e),[o]=C("map/region-id")(e),[r]=C("palette/local-grid")(e);if(!n||!o)return e;const s=($=this.config.minRegionArea)!=null?$:120,a=n.levels[0],c=n.levels[1],i=a.regions.length,l=new Uint32Array(i);if(c)for(const b of c.regions)for(const u of b.memberSegments)l[u]=b.id;const d=new Uint32Array(i);for(let b=0;b<i;b++)a.regions[b].area>=s||!c?d[b]=b:d[b]=i+l[b];const f=new Uint32Array(o.data.length),g=new Map;for(let b=0;b<o.data.length;b++){const u=o.data[b],x=d[u];let S=g.get(x);S===void 0&&(S=g.size,g.set(x,S)),f[b]=S}const h=[];for(const[b,u]of g.entries())if(b<i){const x=a.regions[b];h[u]={id:u,memberSegments:[...x.memberSegments],area:x.area,meanColor:x.meanColor,depth:0}}else if(c){const x=c.regions[b-i];h[u]={id:u,memberSegments:[...x.memberSegments],area:x.area,meanColor:x.meanColor,depth:1}}const{regions:m,componentMap:y}=Ht(f,h,o.width,o.height);if(r)for(const b of m)r.tiles.find(x=>x.colors.some(S=>ct(S,b.meanColor)<30))&&(b.depth=Math.min((M=b.depth)!=null?M:0,.5));const{regions:v,componentMap:p}=Qt(y,m,o.width,o.height,s),w={id:P(),kind:"regions/final",regions:v,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{minArea:s}}},A={id:P(),kind:"map/region-id",width:o.width,height:o.height,data:p,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id,w.id]}};return F(e,[w,A])}}function ct(t,e){const n=t.r-e.r,o=t.g-e.g,r=t.b-e.b;return Math.sqrt(n*n+o*o+r*r)}function Ht(t,e,n,o){var f,g,h;const r=t.length,s=new Uint8Array(r),a=new Uint32Array(r),c=new Uint32Array(r),i=[];let l=0;const d={r:0,g:0,b:0,a:255};for(let m=0;m<r;m++){if(s[m])continue;const y=t[m],v=(f=e[y])!=null?f:{memberSegments:[],meanColor:d,depth:0};let p=0,w=0;c[w++]=m,s[m]=1;let A=0;for(;p<w;){const $=c[p++];a[$]=l,A++;const M=$%n,b=Math.floor($/n),u=x=>{s[x]||t[x]===y&&(s[x]=1,c[w++]=x)};M>0&&u($-1),M+1<n&&u($+1),b>0&&u($-n),b+1<o&&u($+n)}i.push({id:l,memberSegments:[...(g=v.memberSegments)!=null?g:[]],area:A,meanColor:(h=v.meanColor)!=null?h:d,depth:v.depth}),l++}return{regions:i,componentMap:a}}function Qt(t,e,n,o,r){var h,m,y,v;const s=new Set;for(const p of e)p.area<r&&s.add(p.id);if(s.size===0)return{regions:e,componentMap:t};const a=Zt(t,n,o),c=new Map;for(const p of s){const w=a.get(p);if(!w||w.size===0)continue;const A=[];for(const u of w)s.has(u)||A.push(u);if(A.length===0)continue;const $=e[p];let M=A[0],b=ct($.meanColor,e[M].meanColor);for(let u=1;u<A.length;u++){const x=A[u],S=ct($.meanColor,e[x].meanColor);S<b&&(b=S,M=x)}c.set(p,M)}const i=new Uint32Array(t.length),l=new Map;for(let p=0;p<t.length;p++){const w=t[p],A=(h=c.get(w))!=null?h:w;i[p]=A,l.set(A,((m=l.get(A))!=null?m:0)+1)}const d=[],f=new Map;for(const p of e){if(c.has(p.id))continue;const w=d.length;f.set(p.id,w),d.push({...p,id:w,area:(y=l.get(p.id))!=null?y:p.area})}const g=new Uint32Array(i.length);for(let p=0;p<i.length;p++){const w=i[p];g[p]=(v=f.get(w))!=null?v:0}return{regions:d,componentMap:g}}function Zt(t,e,n){const o=new Map;for(let r=0;r<n;r++)for(let s=0;s<e;s++){const a=r*e+s,c=t[a];if(s<e-1){const i=t[a+1];i!==c&&(o.has(c)||o.set(c,new Set),o.has(i)||o.set(i,new Set),o.get(c).add(i),o.get(i).add(c))}if(r<n-1){const i=t[a+e];i!==c&&(o.has(c)||o.set(c,new Set),o.has(i)||o.set(i,new Set),o.get(c).add(i),o.get(i).add(c))}}return o}class Jt{constructor(e={}){z(this,"desc",{name:"preprocess/downscale",consumes:["raster/source"],produces:["raster/source"]});this.config=e}async run(e){var g;const[n]=C("raster/source")(e);if(!n)return e;const o=(g=this.config.maxPixels)!=null?g:2e6,{width:r,height:s}=n,a=r*s;if(a<=o)return e;const c=Math.sqrt(o/a),i=Math.floor(r*c),l=Math.floor(s*c),d=te(n.data,r,s,i,l),f={id:P(),kind:"raster/source",width:i,height:l,data:d,colorSpace:n.colorSpace,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{originalWidth:r,originalHeight:s,maxPixels:o,scale:c}}};return F(e,[f])}}function te(t,e,n,o,r){const s=new Uint8ClampedArray(o*r*4),a=e/o,c=n/r;for(let i=0;i<r;i++)for(let l=0;l<o;l++){const d=l*a,f=i*c,g=Math.floor(d),h=Math.floor(f),m=Math.min(g+1,e-1),y=Math.min(h+1,n-1),v=d-g,p=f-h,w=(h*e+g)*4,A=(h*e+m)*4,$=(y*e+g)*4,M=(y*e+m)*4,b=(i*o+l)*4;for(let u=0;u<4;u++){const x=t[w+u],S=t[A+u],E=t[$+u],I=t[M+u],D=x*(1-v)+S*v,R=E*(1-v)+I*v,T=D*(1-p)+R*p;s[b+u]=Math.round(T)}}return s}const O=4294967295;class ee{constructor(e={}){z(this,"desc",{name:"segments/edge-aware-init",consumes:["feature/multiscale","map/palette-index","raster/rgb"],produces:["segments/edge-aware","map/segment-id"],optional:["raster/lab"]});this.config=e}async run(e){var L,N,q,U,V,Y,H,et;const[n]=C("feature/multiscale")(e),[o]=C("map/palette-index")(e),[r]=C("raster/rgb")(e);if(!n||!o||!r)return e;const[s]=C("raster/lab")(e),a=(L=s==null?void 0:s.data)!=null?L:r.data,c=s!==void 0,{width:i,height:l,data:d}=r,f=i*l,g=new Uint32Array(f);g.fill(O);const h=(N=n.levels[0])!=null?N:n.levels[n.levels.length-1],m=(q=h==null?void 0:h.data)!=null?q:new Float32Array(f*2),y=(U=h==null?void 0:h.featureCount)!=null?U:2,v=(V=this.config.edgeThreshold)!=null?V:.12,p=(Y=this.config.minSegmentSize)!=null?Y:32,w=(H=this.config.colorTolerance)!=null?H:.18,A=w*w,$=Math.max(4,Math.floor((et=this.config.seedSpacing)!=null?et:28)),M=new Uint32Array(f),b=new Uint32Array(f);let u=0,x=0;const S=new Map;let E=0;const I=ne(i,l,$,m,y);I.sort((k,B)=>k.priority-B.priority);for(const k of I){if(g[k.index]!==O)continue;const B=o.indices[k.index],_=E++,nt=pt(_,k.x,k.y,B,k.index,a);S.set(_,nt),g[k.index]=_,Z(nt,k.index,i,d),M[x]=k.index,b[x]=_,x++}xt({queueIndex:M,queueSegment:b,assignments:g,accumulators:S,paletteIndices:o.indices,data:d,colorData:a,isLab:c,gradients:m,gradientStride:y,width:i,height:l,edgeThreshold:v,colorToleranceSq:A,headRef:()=>u,tailRef:()=>x,setHeadTail:(k,B)=>{u=k,x=B}});for(let k=0;k<f;k++){if(g[k]!==O)continue;const B=k%i,_=Math.floor(k/i),nt=o.indices[k],ot=E++,Rt=pt(ot,B,_,nt,k,d);S.set(ot,Rt),g[k]=ot,Z(Rt,k,i,d),M[x]=k,b[x]=ot,x++}xt({queueIndex:M,queueSegment:b,assignments:g,accumulators:S,paletteIndices:o.indices,data:d,colorData:a,isLab:c,gradients:m,gradientStride:y,width:i,height:l,edgeThreshold:v,colorToleranceSq:A,headRef:()=>u,tailRef:()=>x,setHeadTail:(k,B)=>{u=k,x=B}}),re(S,g,p,A),ie(g,S,i,l,d);const D=[...S.values()].filter(k=>k.area>0),R=new Map,T=D.map((k,B)=>(R.set(k.id,B),ae({...k,id:B})));for(let k=0;k<g.length;k++){const B=R.get(g[k]);B!==void 0&&(g[k]=B)}const G={id:P(),kind:"segments/edge-aware",segments:T,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[r.id,n.id,o.id,...s?[s.id]:[]],params:{edgeThreshold:v,minSegmentSize:p,colorTolerance:w,seedSpacing:$}}},W={id:P(),kind:"map/segment-id",width:i,height:l,data:g,segmentCount:T.length,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[G.id]}};return F(e,[G,W])}}function ne(t,e,n,o,r){var l;const s=[],a=Math.max(1,Math.ceil(t/n)),c=Math.max(1,Math.ceil(e/n)),i=n/2;for(let d=0;d<c;d++){const f=Math.min(e-1,Math.round(d*n+i));for(let g=0;g<a;g++){const h=Math.min(t-1,Math.round(g*n+i)),m=f*t+h,y=(l=o[m*r])!=null?l:0;s.push({index:m,x:h,y:f,priority:y})}}return s}function pt(t,e,n,o,r,s){const a=r*4;return{id:t,seedX:e,seedY:n,paletteIndex:o,seedR:s[a],seedG:s[a+1],seedB:s[a+2],area:0,sumR:0,sumG:0,sumB:0,minX:Number.POSITIVE_INFINITY,minY:Number.POSITIVE_INFINITY,maxX:Number.NEGATIVE_INFINITY,maxY:Number.NEGATIVE_INFINITY,pixels:[],neighborSegments:new Set}}function xt(t){var o;let e=t.headRef(),n=t.tailRef();for(;e<n;){const r=t.queueIndex[e],s=t.queueSegment[e];e++;const a=t.accumulators.get(s);if(!a||a.area===0)continue;const c=r%t.width,i=Math.floor(r/t.width);for(const[l,d]of bt(c,i,t.width,t.height)){const f=d*t.width+l,g=t.assignments[f];if(g===s)continue;if(g!==O){a.neighborSegments.add(g);const u=t.accumulators.get(g);u&&u.neighborSegments.add(s);continue}if(t.paletteIndices[f]!==a.paletteIndex||((o=t.gradients[f*t.gradientStride])!=null?o:0)>t.edgeThreshold)continue;const m=f*4,y=t.colorData[m],v=t.colorData[m+1],p=t.colorData[m+2],w=a.sumR/a.area,A=a.sumG/a.area,$=a.sumB/a.area;let M,b;if(t.isLab){const[u,x,S]=Q(w,A,$);M=ut(y,v,p,u,x,S),b=ut(y,v,p,a.seedR,a.seedG,a.seedB)}else{const u=y-w,x=v-A,S=p-$;M=u*u+x*x+S*S;const E=y-a.seedR,I=v-a.seedG,D=p-a.seedB;b=E*E+I*I+D*D}M>t.colorToleranceSq||b>t.colorToleranceSq||(t.assignments[f]=s,Z(a,f,t.width,t.data),t.queueIndex[n]=f,t.queueSegment[n]=s,n++)}}t.setHeadTail(0,0)}function Z(t,e,n,o){const r=e%n,s=Math.floor(e/n),a=e*4;t.pixels.push(e),t.area+=1,t.sumR+=o[a],t.sumG+=o[a+1],t.sumB+=o[a+2],r<t.minX&&(t.minX=r),r>t.maxX&&(t.maxX=r),s<t.minY&&(t.minY=s),s>t.maxY&&(t.maxY=s)}function oe(t,e,n){var i;let o,r=Number.POSITIVE_INFINITY;const s=t.sumR/t.area,a=t.sumG/t.area,c=t.sumB/t.area;for(const l of t.neighborSegments){if(l===t.id)continue;const d=e.get(l);if(!d||d.area===0)continue;const f=d.sumR/d.area,g=d.sumG/d.area,h=d.sumB/d.area,m=f-s,y=g-a,v=h-c,p=m*m+y*y+v*v;if(p>n*4)continue;const w=p+1/Math.max(d.area,1);(w<r||w===r&&d.area>((i=o==null?void 0:o.area)!=null?i:0))&&(r=w,o=d)}return o}function se(t,e,n,o){for(const r of e.pixels)n[r]=t.id;t.area+=e.area,t.sumR+=e.sumR,t.sumG+=e.sumG,t.sumB+=e.sumB,t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY);for(const r of e.pixels)t.pixels.push(r);t.neighborSegments.delete(e.id);for(const r of e.neighborSegments){if(r===t.id)continue;t.neighborSegments.add(r);const s=o.get(r);s&&(s.neighborSegments.delete(e.id),s.neighborSegments.add(t.id))}}function re(t,e,n,o){const r=[...t.values()].filter(s=>s.area<n);r.sort((s,a)=>s.area-a.area);for(const s of r){const a=t.get(s.id);if(!a||a.area>=n)continue;const c=oe(a,t,o);c&&(se(c,a,e,t),t.delete(a.id))}}function ie(t,e,n,o,r){for(let s=0;s<t.length;s++){if(t[s]!==O)continue;const a=s%n,c=Math.floor(s/n);let i;for(const[l,d]of bt(a,c,n,o)){const f=t[d*n+l];if(f!==O&&(i=e.get(f),i))break}i&&(t[s]=i.id,Z(i,s,n,r))}}function ae(t){const e=t.sumR/t.area,n=t.sumG/t.area,o=t.sumB/t.area;return{id:t.id,area:t.area,meanColor:{r:Math.round(e*255),g:Math.round(n*255),b:Math.round(o*255),a:255},bounds:{x:t.minX,y:t.minY,w:t.maxX-t.minX+1,h:t.maxY-t.minY+1}}}function*bt(t,e,n,o){t>0&&(yield[t-1,e]),t+1<n&&(yield[t+1,e]),e>0&&(yield[t,e-1]),e+1<o&&(yield[t,e+1])}class ce{constructor(e={}){z(this,"desc",{name:"regions/hierarchy-build",consumes:["graph/segment-affinity","segments/edge-aware","map/segment-id"],produces:["regions/hierarchy","map/region-id"]});this.config=e}async run(e){var A,$;const[n]=C("graph/segment-affinity")(e),[o]=C("segments/edge-aware")(e),[r]=C("map/segment-id")(e);if(!n||!o||!r)return e;const s=o.segments.length,a=(A=this.config.mergeThreshold)!=null?A:.18,c=new Uint32Array(s);for(let M=0;M<s;M++)c[M]=M;const i=M=>{let b=M;for(;c[b]!==b;)b=c[b];let u=M;for(;c[u]!==b;){const x=c[u];c[u]=b,u=x}return b},l=(M,b)=>{const u=i(M),x=i(b);u!==x&&(c[x]=u)},d=[...n.edges].sort((M,b)=>M.weight-b.weight);for(const M of d)M.weight<=a&&l(M.from,M.to);const f=new Map,g=[];for(let M=0;M<s;M++){const b=i(M);if(!f.has(b)){const S=f.size;f.set(b,S),g.push({id:S,memberSegments:[],area:0,meanColor:{r:0,g:0,b:0,a:255},depth:1})}const u=g[f.get(b)],x=o.segments[M];u.memberSegments.push(x.id),u.area+=x.area,u.meanColor.r+=x.meanColor.r*x.area,u.meanColor.g+=x.meanColor.g*x.area,u.meanColor.b+=x.meanColor.b*x.area}for(const M of g){const b=Math.max(M.area,1);M.meanColor.r=Math.round(M.meanColor.r/b),M.meanColor.g=Math.round(M.meanColor.g/b),M.meanColor.b=Math.round(M.meanColor.b/b)}const h={level:0,regions:o.segments.map(M=>({id:M.id,memberSegments:[M.id],area:M.area,meanColor:M.meanColor,depth:0}))},m={level:1,regions:g},y=[];y.push(new Uint32Array(r.data));const v=new Uint32Array(r.data.length);for(let M=0;M<r.data.length;M++){const b=r.data[M];v[M]=($=f.get(i(b)))!=null?$:b}y.push(v);const p={id:P(),kind:"regions/hierarchy",width:r.width,height:r.height,levels:[h,m],segmentToRegion:le(s),levelMaps:y,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id,o.id],params:{mergeThreshold:a}}},w={id:P(),kind:"map/region-id",width:r.width,height:r.height,data:new Uint32Array(r.data),provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[p.id]}};return F(e,[p,w])}}function le(t){const e=new Uint32Array(t);for(let n=0;n<t;n++)e[n]=n;return e}class de{constructor(e={}){z(this,"desc",{name:"palette/local-synthesis",consumes:["raster/rgb"],produces:["palette/local-grid","map/palette-index"]});this.config=e}async run(e){var m,y;const[n]=C("raster/rgb")(e);if(!n)return e;const o=(m=this.config.tileSize)!=null?m:32,r=(y=this.config.maxColorsPerTile)!=null?y:4,{width:s,height:a,data:c}=n,i=[],l=new Uint8Array(s*a),d=Math.ceil(s/o),f=Math.ceil(a/o);for(let v=0;v<f;v++)for(let p=0;p<d;p++){const w=[];let A=0,$=0,M=0,b=0;const u=p*o,x=v*o,S=Math.min(o,s-u),E=Math.min(o,a-x);for(let R=0;R<E;R++)for(let T=0;T<S;T++){const G=u+T,L=(x+R)*s+G,N=L*4,q=c[N],U=c[N+1],V=c[N+2];A+=q,$+=U,M+=V,b++;const Y=fe(w,q,U,V,r);l[L]=Y}const I=w.map(R=>({r:Math.round(R.r*255),g:Math.round(R.g*255),b:Math.round(R.b*255),a:255})),D={tileX:p,tileY:v,width:S,height:E,colors:I,averageColor:{r:b?Math.round(A/b*255):0,g:b?Math.round($/b*255):0,b:b?Math.round(M/b*255):0,a:255},coverage:b};i.push(D)}const g={id:P(),kind:"palette/local-grid",width:s,height:a,tileSize:o,tiles:i,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{tileSize:o,maxColors:r}}},h={id:P(),kind:"map/palette-index",width:s,height:a,indices:l,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id,g.id]}};return F(e,[g,h])}}function fe(t,e,n,o,r){if(t.length===0)return t.push({r:e,g:n,b:o,count:1}),0;let s=0,a=Number.POSITIVE_INFINITY;for(let l=0;l<t.length;l++){const d=t[l],f=e-d.r,g=n-d.g,h=o-d.b,m=f*f+g*g+h*h;m<a&&(a=m,s=l)}if(t.length<r&&a>.005)return t.push({r:e,g:n,b:o,count:1}),t.length-1;const c=t[s],i=c.count+1;return c.r=(c.r*c.count+e)/i,c.g=(c.g*c.count+n)/i,c.b=(c.b*c.count+o)/i,c.count=i,s}class ge{constructor(e={}){z(this,"desc",{name:"features/multiscale",consumes:["raster/rgb"],produces:["feature/multiscale"]});this.config=e}async run(e){var l;const[n]=C("raster/rgb")(e);if(!n)return e;const{width:o,height:r,data:s}=n,a=(l=this.config.scales)!=null?l:[1,2],c=a.map(d=>{const f=new Float32Array(o*r*2);return he(o,r,s,d,f),{scale:d,featureCount:2,data:f}}),i={id:P(),kind:"feature/multiscale",width:o,height:r,levels:c,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{scales:a}}};return F(e,[i])}}function he(t,e,n,o,r){const a=new Float32Array(t*e);for(let c=0;c<e;c++)for(let i=0;i<t;i++){const l=(c*t+i)*4;a[c*t+i]=.2126*n[l]+.7152*n[l+1]+.0722*n[l+2]}for(let c=0;c<e;c++)for(let i=0;i<t;i++){const l=a[c*t+i],d=a[c*t+j(i+o,0,t-1)],f=a[c*t+j(i-o,0,t-1)],g=a[j(c+o,0,e-1)*t+i],h=a[j(c-o,0,e-1)*t+i],m=d-f,y=g-h,v=Math.hypot(m,y);let p=0,w=0;for(let $=-o;$<=o;$++)for(let M=-o;M<=o;M++){const b=j(i+M,0,t-1),u=j(c+$,0,e-1);p+=Math.abs(a[u*t+b]-l),w++}p=w>0?p/w:0;const A=(c*t+i)*2;r[A]=v,r[A+1]=p}}function j(t,e,n){return t<e?e:t>n?n:t}class ue{constructor(e={}){z(this,"desc",{name:"paths/polyline-smoothing",consumes:["topology/region-contours"],produces:["topology/region-contours"]});this.config=e}async run(e){var a;const[n]=C("topology/region-contours")(e);if(!n)return e;const o=(a=this.config.sigma)!=null?a:1,r=n.contours.map(c=>({regionId:c.regionId,outer:yt(c.outer,o),holes:c.holes.map(i=>yt(i,o))})),s={id:P(),kind:"topology/region-contours",width:n.width,height:n.height,contours:r,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{sigma:o}}};return F(e,[s])}}function yt(t,e){var a,c;const n=Array.from(t.points),o=n.length/2;if(o<3)return t;const r=Math.ceil(e*3),s=new Float32Array(n.length);for(let i=0;i<o;i++){if(!t.closed&&(i===0||i===o-1)){s[i*2]=n[i*2],s[i*2+1]=n[i*2+1];continue}if((c=(a=t.sharedVertexIndices)==null?void 0:a.has(i))!=null?c:!1)s[i*2]=n[i*2],s[i*2+1]=n[i*2+1];else{let d=0,f=0,g=0;for(let h=-r;h<=r;h++){let m=i+h;t.closed?m=(m%o+o)%o:m=Math.max(0,Math.min(o-1,m));const y=n[m*2]-n[i*2],v=n[m*2+1]-n[i*2+1],p=Math.sqrt(y*y+v*v),w=Math.exp(-(p*p)/(2*e*e));d+=n[m*2]*w,f+=n[m*2+1]*w,g+=w}s[i*2]=d/g,s[i*2+1]=f/g}}return{points:s,closed:t.closed,sharedVertexIndices:t.sharedVertexIndices}}class me{constructor(e={}){z(this,"desc",{name:"normalize/radiometric",consumes:["raster/source"],produces:["raster/rgb"]});this.config=e}async run(e){var y,v,p;const[n]=C("raster/source")(e);if(!n)return e;const{width:o,height:r,data:s}=n,a=o*r,c=new Float32Array(a*4);let i=0;for(let w=0;w<a;w++){const A=s[w*4]/255,$=s[w*4+1]/255,M=s[w*4+2]/255;i+=.2126*A+.7152*$+.0722*M}const l=(y=this.config.targetMean)!=null?y:.5,d=(v=this.config.minGain)!=null?v:.6,f=(p=this.config.maxGain)!=null?p:1.8,g=a>0?i/a:1e-4,h=J(l/g*.95,d,f);for(let w=0;w<a;w++)c[w*4]=J(s[w*4]/255*h,0,1),c[w*4+1]=J(s[w*4+1]/255*h,0,1),c[w*4+2]=J(s[w*4+2]/255*h,0,1),c[w*4+3]=s[w*4+3]/255;const m={id:P(),kind:"raster/rgb",width:o,height:r,coordSpace:n.coordSpace,channels:4,data:c,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id],params:{gain:h,targetMean:l}}};return F(e,[m])}}function J(t,e,n){return Math.max(e,Math.min(n,t))}class pe{constructor(e={}){z(this,"desc",{name:"segments/affinity-graph",consumes:["segments/edge-aware","map/segment-id","raster/rgb"],produces:["graph/segment-affinity"],optional:["raster/lab"]});this.config=e}async run(e){var $,M,b;const[n]=C("segments/edge-aware")(e),[o]=C("map/segment-id")(e),[r]=C("raster/rgb")(e);if(!n||!o||!r)return e;const[s]=C("raster/lab")(e),a=($=s==null?void 0:s.data)!=null?$:r.data,c=s!==void 0,{width:i,height:l,data:d}=r,{segments:f}=n,g=f.map(u=>({id:u.id,area:u.area,meanColor:u.meanColor,variance:0})),h=new Array(f.length).fill(0);for(let u=0;u<i*l;u++){const x=o.data[u];if(x>=f.length)continue;const S=f[x].meanColor,E=d[u*4]*255,I=d[u*4+1]*255,D=d[u*4+2]*255,R=(E-S.r)**2+(I-S.g)**2+(D-S.b)**2;h[x]+=R}for(const u of g)u.variance=u.area?h[u.id]/u.area:0;const m=new Map,y=(M=this.config.smoothnessWeight)!=null?M:.6,v=(b=this.config.boundaryWeight)!=null?b:.75,p=i*l;for(let u=0;u<p;u++){const x=u%i,S=Math.floor(u/i),E=o.data[u];if(x+1<i){const I=o.data[u+1];I!==E&&wt(m,E,I,f,St(a,u,u+1,c),c)}if(S+1<l){const I=o.data[u+i];I!==E&&wt(m,E,I,f,St(a,u,u+i,c),c)}}const w=[];for(const u of m.values()){const x=u.samples>0?u.boundarySum/u.samples:0,S=Math.max(x,u.boundaryMax*.8),E=Math.max(u.minColorWeight,Mt(S*v)),I=Mt(E)+y*u.maxContrast;w.push({from:u.from,to:u.to,weight:I,contrast:u.maxContrast})}const A={id:P(),kind:"graph/segment-affinity",nodes:g,edges:w,provenance:{createdAt:Date.now(),step:this.desc.name,sourceIds:[n.id,o.id],params:{smoothnessWeight:y,boundaryWeight:v}}};return F(e,[A])}}function wt(t,e,n,o,r,s){var d,f;const a=e<n?`${e}:${n}`:`${n}:${e}`,c=xe(o[e].meanColor,o[n].meanColor,s),i=Math.abs(((d=o[e].variance)!=null?d:0)-((f=o[n].variance)!=null?f:0)),l=t.get(a);l?(l.minColorWeight=Math.min(l.minColorWeight,c),l.maxContrast=Math.max(l.maxContrast,i),l.boundarySum+=r,r>l.boundaryMax&&(l.boundaryMax=r),l.samples+=1):t.set(a,{from:e,to:n,minColorWeight:c,maxContrast:i,boundarySum:r,boundaryMax:r,samples:1})}function xe(t,e,n){if(n){const[a,c,i]=Q(t.r/255,t.g/255,t.b/255),[l,d,f]=Q(e.r/255,e.g/255,e.b/255);return ht(a,c,i,l,d,f)/100}const o=t.r-e.r,r=t.g-e.g,s=t.b-e.b;return Math.sqrt(o*o+r*r+s*s)/441}function St(t,e,n,o){const r=e*4,s=n*4;if(o){const d=t[r],f=t[r+1],g=t[r+2],h=t[s],m=t[s+1],y=t[s+2];return ht(d,f,g,h,m,y)/100}const a=t[r]-t[s],c=t[r+1]-t[s+1],i=t[r+2]-t[s+2];return Math.sqrt(a*a+c*c+i*i)*be}function Mt(t){return Number.isNaN(t)||t<0?0:t>1?1:t}const be=1/Math.sqrt(3);class ye{constructor(e={}){z(this,"desc",{name:"export/svg-assembly",consumes:["map/region-id","regions/final","style/fills"],produces:["svg/document"],optional:["paths/bezier"]});this.config=e}async run(e){var b,u,x,S,E;const[n]=C("map/region-id")(e),[o]=C("regions/final")(e),[r]=C("style/fills")(e);if(!n||!o||!r)return e;const s=n.width,a=n.height,c=n.data,i=`0 0 ${s} ${a}`,[l]=C("paths/bezier")(e),d=l!==void 0,f=new Map,g=new Map;for(const I of r.fills)f.set(I.regionId,I.fill),g.set(I.regionId,(b=I.opacity)!=null?b:1);const h=new Map;if(d&&l)for(const I of l.paths)h.set(I.regionId,I.d);const m=o.regions.toSorted((I,D)=>{var R,T;return((R=D.area)!=null?R:0)-((T=I.area)!=null?T:0)}),y=(u=this.config.precision)!=null?u:2,v=(x=this.config.simplifyColinear)!=null?x:!0,p=(S=this.config.strokeWidth)!=null?S:1,w=m.map(I=>{var V,Y,H;const D=f.get(I.id);if(!D)return"";let R;if(d?(R=(V=h.get(I.id))!=null?V:"",R||(R=vt(I.id,c,s,a).map(k=>$t(v?It(k):k,y)).filter(Boolean).join(" "))):R=vt(I.id,c,s,a).map(k=>$t(v?It(k):k,y)).filter(Boolean).join(" "),!R)return"";const T=Ct(D.r,D.g,D.b),G=(Y=g.get(I.id))!=null?Y:1,W=((H=D.a)!=null?H:255)/255,L=Se(W*G),N=L<.999?` fill-opacity="${lt(L)}"`:"",q=L<.999?` stroke-opacity="${lt(L)}"`:"",U=p>0?` stroke="${T}" stroke-width="${we(p)}" stroke-linejoin="round" stroke-linecap="round"${q}`:"";return`<path d="${R}" fill="${T}"${N}${U} fill-rule="evenodd" />`}).filter(Boolean).join(`
  `),A=r.background?(()=>{var T;const I=Ct(r.background.r,r.background.g,r.background.b),D=((T=r.background.a)!=null?T:255)/255,R=D<.999?` fill-opacity="${lt(D)}"`:"";return`<rect width="100%" height="100%" fill="${I}"${R} />`})():"",$=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="${i}">
  ${A}
  ${w}
</svg>`,M={id:P(),kind:"svg/document",svg:$,provenance:{createdAt:Date.now(),sourceIds:[n.id,r.id],step:this.desc.name,params:{precision:(E=this.config.precision)!=null?E:2}}};return F(e,[M])}}function vt(t,e,n,o){const r=[],s=new Set,a=(g,h,m,y)=>{const v=`${g},${h}->${m},${y}`;s.has(v)||(s.add(v),r.push({startX:g,startY:h,endX:m,endY:y}))};for(let g=0;g<o;g++)for(let h=0;h<n;h++)e[g*n+h]===t&&((g===0||e[(g-1)*n+h]!==t)&&a(h,g,h+1,g),(h===n-1||e[g*n+h+1]!==t)&&a(h+1,g,h+1,g+1),(g===o-1||e[(g+1)*n+h]!==t)&&a(h+1,g+1,h,g+1),(h===0||e[g*n+h-1]!==t)&&a(h,g+1,h,g));if(r.length===0)return[];const c=(g,h)=>`${g},${h}`,i=new Map;for(const g of r){const h=c(g.startX,g.startY),m=i.get(h);m?m.push(g):i.set(h,[g])}const l=[];let d=0;const f=r.length+100;for(;i.size>0&&!(++d>f);){const g=i.entries().next();if(!g.value)break;const[h,m]=g.value,y=m.pop();m.length===0&&i.delete(h);const v=[];v.push(y.startX,y.startY);let p=y.endX,w=y.endY;v.push(p,w);let A=0;const $=n*o*4;for(;!(p===y.startX&&w===y.startY)&&!(++A>$);){const M=c(p,w),b=i.get(M);if(!b||b.length===0)break;const u=b.pop();b.length===0&&i.delete(M),p=u.endX,w=u.endY,v.push(p,w)}l.push(v)}return l.sort((g,h)=>At(h)-At(g)),l}function At(t){let e=0;for(let n=0;n<t.length-2;n+=2){const o=t[n],r=t[n+1],s=t[n+2],a=t[n+3];e+=o*a-s*r}return Math.abs(e)*.5}function $t(t,e){if(t.length<4)return"";const n=s=>s.toFixed(e),o=[...t];o[0]===o[o.length-2]&&o[1]===o[o.length-1]&&o.splice(o.length-2,2);let r=`M${n(o[0])},${n(o[1])}`;for(let s=2;s<o.length;s+=2)r+=`L${n(o[s])},${n(o[s+1])}`;return r+="Z",r}function It(t){if(t.length<=8)return t;const e=[],n=t.length/2,o=s=>t[s%n*2],r=s=>t[s%n*2+1];e.push(t[0],t[1]);for(let s=1;s<n-1;s++){const a=o(s-1),c=r(s-1),i=o(s),l=r(s),d=o(s+1),f=r(s+1),g=i-a,h=l-c,m=d-i,y=f-l;g===0&&m===0||h===0&&y===0||e.push(i,l)}return e.push(t[t.length-2],t[t.length-1]),e}function Ct(t,e,n){const o=r=>Math.max(0,Math.min(255,Math.round(r))).toString(16).padStart(2,"0");return`#${o(t)}${o(e)}${o(n)}`}function lt(t){return t.toFixed(t<.1?3:2).replace(/0+$/,"").replace(/\.$/,"")}function we(t){return t%1===0?t.toFixed(0):t.toFixed(2)}function Se(t){return Number.isNaN(t)||t<0?0:t>1?1:t}function Me({maxPixels:t=2e6,normalizationTarget:e=.5,useBilateralFilter:n=!0,bilateralSigmaSpatial:o=3,bilateralSigmaRange:r=.1,useLabColorSpace:s=!0,useBezierCurves:a=!0,usePolylineSmoothing:c=!0,polylineSmoothingSigma:i=1,useDCELSmoothing:l=!1,dcelSmoothingIterations:d=3,dcelSmoothingLambda:f=.5,bezierTolerance:g=1,bezierMinSegmentLength:h=4,featureScales:m=[1,2],tileSize:y=32,maxTileColors:v=4,edgeThreshold:p=.12,minSegmentSize:w=48,colorTolerance:A=.18,seedSpacing:$=28,mergeThreshold:M=.18,minRegionArea:b=120,svgPrecision:u=2,background:x}={}){const S=new st("nextgen-vectorization");return S.addStep(new Jt({maxPixels:t})),S.addStep(new me({targetMean:e})),n&&S.addStep(new Xt({sigmaSpatial:o,sigmaRange:r})),s&&S.addStep(new Ot),S.addStep(new ge({scales:m})),S.addStep(new de({tileSize:y,maxColorsPerTile:v})),S.addStep(new ee({edgeThreshold:p,minSegmentSize:w,colorTolerance:A,seedSpacing:$})),S.addStep(new pe),S.addStep(new ce({mergeThreshold:M})),S.addStep(new _t({minRegionArea:b})),S.addStep(new Vt({background:x})),a&&(S.addStep(new jt({useSubpixelRefinement:!0,gradientThreshold:.1,useDCELSmoothing:l,dcelSmoothingIterations:d,dcelSmoothingLambda:f})),c&&S.addStep(new ue({sigma:i})),S.addStep(new Nt({tolerance:g,minSegmentLength:h}))),S.addStep(new ye({precision:u})),S}function ve(t){const e=[];return[...t.byKind.keys()].forEach(o=>{const[r]=C(o)(t);if(!r)return;const s=Ae(r);s&&e.push(s)}),e}function Ae(t){switch(t.kind){case"raster/source":return Ce(t);case"palette/final":return $e(t);case"paths/bezier":return Ie(t);default:return}}function $e(t){const e=t.colors.length,n=t.colors.reduce((i,l)=>i+(l.weight||1),0),o=n/e,r=50,s=30,a=Ee(e*r,s),c=a.getContext("2d");return t.colors.forEach((i,l)=>{const{r:d,g:f,b:g,a:h=255}=i.rgba;c.fillStyle=`rgba(${d}, ${f}, ${g}, ${h/255})`,c.fillRect(l*r,0,r,s)}),{artifactType:"palette/final",artifactId:t.id,summary:`${e} colors extracted`,details:{colorCount:e,totalWeight:n.toFixed(2),avgWeight:o.toFixed(2),colors:t.colors.map(i=>{var l;return{rgba:i.rgba,weight:((l=i.weight)==null?void 0:l.toFixed(3))||"1.000"}})},visualization:a.toDataURL()}}function Ie(t){const e=t.paths.length;return{artifactType:"paths/bezier",artifactId:t.id,summary:`${e} vector paths`,details:{pathCount:e,paths:t.paths.slice(0,10)}}}function Ce(t){const{width:e,height:n,colorSpace:o}=t,r=e*n;let s="No pixel data available";if(t.data){const a=t.data,c=ke(a),i=r-c,l=(c/r*100).toFixed(1);s=`${i} opaque, ${c} transparent (${l}% transparent)`}return{artifactType:"raster/source",artifactId:t.id,summary:`${e}×${n} raster image`,details:{width:e,height:n,totalPixels:r,colorSpace:o,coordSpace:t.coordSpace,pixelAnalysis:s,hasPixelData:!!t.data}}}function ke(t){let e=0;for(let n=3;n<t.length;n+=4)t[n]===0&&e++;return e}function Ee(t,e){if(typeof document!="undefined"){const n=document.createElement("canvas");return n.width=t,n.height=e,n}else return{width:t,height:e,getContext:()=>({fillStyle:"",fillRect:()=>{}}),toDataURL:()=>"data:image/png;base64,mock"}}function Re(t){t.length!==0&&t.forEach((e,n)=>{Object.keys(e.details).length>0&&Object.entries(e.details).forEach(([o,r])=>{}),e.visualization})}function De(t){const{width:e,height:n}=t;if(!t.data)return{svgContent:kt(e,n,"No pixel data available"),title:"Raster Image",description:`${e}×${n} (no pixel data)`};const r=new OffscreenCanvas(e,n).getContext("2d");if(!r)return{svgContent:kt(e,n,"Cannot create canvas context"),title:"Raster Image",description:`${e}×${n} (canvas error)`};const s=new ImageData(new Uint8ClampedArray(t.data),e,n);return r.putImageData(s,0,0),{svgContent:`
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
      <rect width="800" height="600" fill="#f8f9fa"/>
      <text x="400" y="30" text-anchor="middle" font-family="Arial" font-size="16" font-weight="bold">Raster Image: ${e}×${n}</text>
      <g transform="translate(400, 300)">
        <rect x="${-e/2}" y="${-n/2}" width="${e}" height="${n}" fill="white" stroke="#ddd"/>
        <text x="0" y="0" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">
          ${t.data.length/4} pixels
        </text>
      </g>
    </svg>
  `,title:"Raster Image",description:`${e}×${n} pixels, ${t.colorSpace}`}}function ze(t){const e=t.colors,n=e.length,o=60,r=20,s=Math.min(8,n),a=Math.ceil(n/s),c=s*(o+r)+r,i=a*(o+r)+r+80;let l=`
    <svg width="${c}" height="${i}" xmlns="http://www.w3.org/2000/svg">
      <rect width="${c}" height="${i}" fill="#f8f9fa"/>
      <text x="${c/2}" y="30" text-anchor="middle" font-family="Arial" font-size="16" font-weight="bold">
        Color Palette: ${n} colors
      </text>
  `;return e.forEach((d,f)=>{const g=f%s,h=Math.floor(f/s),m=g*(o+r)+r,y=h*(o+r)+r+50,{r:v,g:p,b:w}=d.rgba,A=`#${v.toString(16).padStart(2,"0")}${p.toString(16).padStart(2,"0")}${w.toString(16).padStart(2,"0")}`;l+=`
      <g>
        <rect x="${m}" y="${y}" width="${o}" height="${o}"
              fill="${A}" stroke="#333" stroke-width="1" rx="4"/>
        <text x="${m+o/2}" y="${y+o+15}" text-anchor="middle"
              font-family="Arial" font-size="10" fill="#333">
          ${A}
        </text>
        ${d.weight?`
          <text x="${m+o/2}" y="${y+o+28}" text-anchor="middle"
                font-family="Arial" font-size="8" fill="#666">
            ${(d.weight*100).toFixed(1)}%
          </text>
        `:""}
      </g>
    `}),l+="</svg>",{svgContent:l,title:"Color Palette",description:`${n} extracted colors`}}function Pe(t){const e=t.paths.length;let n=`
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
      <rect width="800" height="600" fill="#f8f9fa"/>
      <text x="400" y="30" text-anchor="middle" font-family="Arial" font-size="16" font-weight="bold">
        Vector Paths: ${e} paths
      </text>
      <g transform="translate(400, 300)">
  `;return t.paths.forEach(o=>{n+=`<path d="${o.d}" fill="#000" stroke="#0C0" stroke-width="1" opacity="1" transform="scale(0.3)"/>`}),n+=`
      </g>
      <text x="400" y="580" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">
        Final vector paths ready for SVG export (showing first 30 paths)
      </text>
    </svg>
  `,{svgContent:n,title:"Vector Paths",description:`${e} bezier paths extracted`}}function kt(t,e,n){return`
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
      <rect width="800" height="600" fill="#fff5f5"/>
      <text x="400" y="280" text-anchor="middle" font-family="Arial" font-size="16" fill="#e53e3e">
        Error: ${n}
      </text>
      <text x="400" y="300" text-anchor="middle" font-family="Arial" font-size="12" fill="#718096">
        Expected size: ${t}×${e}
      </text>
    </svg>
  `}function Et(t){switch(t.kind){case"raster/source":return De(t);case"palette/final":return ze(t);case"paths/bezier":return Pe(t);case"svg/document":default:return null}}self.onmessage=async t=>{const{file:e,options:{config:n,debug:o}}=t.data;try{const r=await Fe(e),s=Me(n);if(o){const{stopAtStep:l}=o,d=s.steps.findIndex(f=>f.desc.name===l.stepName&&f.desc.produces.includes(l.artifactKind));d!==-1&&s.steps.splice(d+1)}const a=l=>{tt({type:"progress",progress:l})},c=await s.execute([r],{onProgress:a});if(o){const l=ve(c);o.enableVerboseLogging&&Re(l);const d=Te(c,o.stopAtStep);tt({type:"complete",data:d});return}const[i]=C("svg/document")(c);if(!i)throw new Error("Pipeline did not generate expected artifacts");tt({type:"complete",data:i.svg})}catch(r){tt({type:"error",data:r instanceof Error?r.message:"Unknown error occurred"})}};const tt=t=>self.postMessage(t);function Te(t,e){try{const[n]=C(e.artifactKind)(t);if(n){const o=Et(n);if(o)return o.svgContent}}catch(n){}try{const n=Array.from(t.artifacts.values()).reverse(),o=["paths/bezier","topology/region-contours","regions/final","segments/edge-aware","palette/final","raster/rgb","raster/source"];for(const r of o){const s=n.find(a=>a.kind===r);if(s){const a=Et(s);if(a)return a.svgContent}}}catch(n){}return Be(e)}async function Fe(t){const e=await createImageBitmap(t),o=new OffscreenCanvas(e.width,e.height).getContext("2d",{willReadFrequently:!0});if(!o)throw new Error("Unable to obtain OffscreenCanvas context");o.drawImage(e,0,0);const r=o.getImageData(0,0,e.width,e.height);return{id:P(),kind:"raster/source",width:e.width,height:e.height,data:r.data,colorSpace:K.sRGB,coordSpace:X.Pixel,meta:{fileName:t.name,fileSize:t.size,mimeType:t.type}}}function Be(t){return`
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
      <rect width="800" height="600" fill="#fff5f5"/>
      <text x="400" y="250" text-anchor="middle" font-family="Arial, sans-serif" font-size="18" font-weight="bold" fill="#e53e3e">
        Stop at Step ${t.stepName}: No Visual Output
      </text>
      <text x="400" y="280" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" fill="#718096">
        Expected artifact type: ${t.artifactKind}
      </text>
      <text x="400" y="310" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" fill="#718096">
        This may indicate an issue in the pipeline at this stage.
      </text>
      <text x="400" y="340" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" fill="#718096">
        Check the console for detailed error information.
      </text>
    </svg>
  `}})();
